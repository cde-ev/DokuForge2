import re

class ParseNode:
	"""
	Abstract base class for all nodes ouf the output tree.
	"""
	pass

class ParseLeaf(ParseNode):
	"""
	Leaf class for the tree generated by the parser.

	This is an abstract class and should only be used for inheritance.

	@ivar data: data contained by the leaf
	@type data: unicode
	"""
	def __init__(self, data):
		self.data = data

	def display(self, indent=0, verbose=False):
		"""
		Print a representation of the ParseLeaf.
		"""
		if not verbose:
			return
		whitespace = indent * u"    "
		print (u"%s %s (%s)" % (whitespace, self.__class__.__name__, self.data)).encode("utf8")

class TokenLeaf(ParseLeaf):
	"""
	Leaf class for tokens.
	"""
	pass

class ParseTree(ParseNode):
	"""
	Tree class for the tree generated by the parser.

	A tree is a root and a list of children, namely self.tree.

	This is an abstract class and should only be used for inheritance.

	@ivar tree: children of the tree
	@type tree: [ParseTree or ParseLeaf]
	"""
	def __init__(self):
		self.tree = []

	def display(self, indent=0, verbose=False):
		"""
		Print a representation of the ParseTree.
		"""
		whitespace = indent * u"    "
		print whitespace + self.__class__.__name__
		for x in self.tree:
			x.display(indent + 1, verbose)


class ROOT(ParseTree):
	"""
	Tree class for the root node.
	"""
	pass

class OUTER(ParseTree):
	"""
	Abstract class for nodes produced by the outer parser.
    """
	pass

class INNER(ParseTree):
	"""
	Abstract class for nodes produced by the inner parser.
    """

class HeadingTree(OUTER):
	"""
	Tree class for headings.
	"""
	pass

class ParagraphTree(OUTER):
	"""
	Tree class for paragraphs.
	"""
	pass

class EmphasisTree(INNER):
	"""
	Tree class for emphasis.
	"""
	pass

class State:
	"""
	Class to keeps the output tree. It's main task is keeping track of
	the current position in the output ParseTree. The idea is that if a
	new leaf or tree has to be appended this class will now where it
	goes.

	For this purpose we have a stack of ParseTrees which contains the
	ParseTrees which constitute the path from the root to the current
	position in the output tree.

	The output tree is the ParseTree self.stack[0]. The current position
	is the tree self.stack[-1].

	@ivar stack: stack which contains the path to the current position
	@type stack: [ParseTree]
	"""
	def __init__(self):
		self.stack = [ROOT()]

	def inserttree(self, tree):
		self.stack[-1].tree.append(tree)
		self.stack.append(tree)

	def insertleaf(self, leaf):
		self.stack[-1].tree.append(leaf)

	def closecontext(self):
		if len(self.stack) > 1:
			self.stack.pop()

	def getcontext(self):
		return self.stack[-1]

	def cleanup(self):
		self.stack = self.stack[0:1]

	def result(self):
		return self.stack[0]

class Parser:
	"""
	The actual parser.

	@ivar inputdata: the input to parse
	@type inputdata: unicode
	@ivar inputpos: the current position of the parser in the input string
	@type inputpos: int
	@ivar state: the current state of the parser, this contains the resulting tree
	@type state: State
	"""
	def __init__(self, inputdata=u""):
		## ensure newline at the end
		if not inputdata.endswith("\n"):
			self.inputdata = inputdata + '\n'
		else:
			self.inputdata = inputdata
		self.inputpos = 0
		self.state = State()

	def retrievechunk(self):
		retcontent = u""
		if self.inputdata[self.inputpos] == '[':
			self.inputpos += 1
			regex = re.compile(u'([ \t]*\][ \t]*\n?|[ \t]*\n[ \t]*\n|$)', re.UNICODE)
			match = regex.search(self.inputdata, self.inputpos)
			retcontent = self.inputdata[self.inputpos:match.start()]
			self.inputpos = match.end()
			rettree = HeadingTree()
		else:
			regex = re.compile(u'\n', re.UNICODE)
			match = regex.search(self.inputdata, self.inputpos)
			retcontent = self.inputdata[self.inputpos:match.start()]
			self.inputpos = match.end()
			rettree = ParagraphTree()
		return rettree, retcontent

	def parsechunk(self, chunk):
		inner = ChunkParser(chunk, self.state)
		inner.parse()

	def parse(self):
		while True:
			if len(self.inputdata) <= self.inputpos:
				break
			## retrieve one line of input
			try:
				currenttree, content = self.retrievechunk()
			except IndexError:
				break
			self.state.inserttree(currenttree)
			self.parsechunk(content)
			self.state.closecontext()

	def result(self):
		return self.state.result()

class ChunkParser:
	"""
	The parser for one chunk.

	@ivar chunk: the input to parse
	@type chunk: unicode
	@ivar pos: the current position of the parser in the chunk
	@type pos: int
	@ivar state: the current state of the parser, this contains the resulting tree
	@type state: State
	"""
	def __init__(self, chunk, state):
		self.chunk = chunk
		self.pos = 0
		self.state = state

	def parse(self):
		context =  self.state.getcontext()
		if isinstance(context, ParagraphTree) or \
		  isinstance(context, HeadingTree):
			self.parseText()
		else:
			raise Exception('unhandled outer structure')

	def parseText(self):
		## no work done here yet
		for i in range(len(self.chunk)):
			self.state.insertleaf(TokenLeaf(self.chunk[i]))

	def parseMath(self):
		## no work done here yet
		for i in range(len(self.chunk)):
			self.state.insertleaf(TokenLeaf(self.chunk[i]))

	def parseEdnote(self):
		## no work done here yet
		for i in range(len(self.chunk)):
			self.state.insertleaf(TokenLeaf(self.chunk[i]))

p = Parser("[heading]\nSome text with _an_ emphasis.\n")
p.parse()
p.result().display(verbose=True)
