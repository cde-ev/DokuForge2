import re

class ParseLeaf:
	"""
	Leaf class for the tree generated by the parser.

	This is an abstract class and should only be used for inheritance.

	@ivar data: data contained by the leaf
	@type data: unicode
	"""
	def __init__(self, data):
		self.data = data

	def display(self, indent=0, verbose=False):
		"""
		Print a representation of the ParseLeaf.
		"""
		if not verbose:
			return
		whitespace = indent * u"    "
		print (u"%sParseLeaf: %s (%s)" % (whitespace, self.ident(), self.data)).encode("utf8")

	def ident(self):
		return "LEAF"

class TokenLeaf(ParseLeaf):
	"""
	Leaf class for tokens.
	"""
	def ident(self):
		return "Token"

class ParseTree:
	"""
	Tree class for the tree generated by the parser.

	A tree is a root and a list of children, namely self.tree.

	This is an abstract class and should only be used for inheritance.

	@ivar tree: children of the tree
	@type tree: [ParseTree or ParseLeaf]
	"""
	def __init__(self):
		self.tree = []

	def display(self, indent=0, verbose=False):
		"""
		Print a representation of the ParseTree.
		"""
		whitespace = indent * u"    "
		print whitespace + u"ParseTree: " + self.ident()
		for x in self.tree:
			x.display(indent + 1, verbose)

	def ident(self):
		return "TREE"


class ROOT(ParseTree):
	"""
	Tree class for the root node.
	"""
	def ident(self):
		return "ROOT"

class HeadingTree(ParseTree):
	"""
	Tree class for headings.
	"""
	def ident(self):
		return "heading"

class ParagraphTree(ParseTree):
	"""
	Tree class for paragraphs.
	"""
	def ident(self):
		return "paragraph"

class EmphasisTree(ParseTree):
	"""
	Tree class for emphasis.
	"""
	def ident(self):
		return "emphasis"

class State:
	"""
	Class to keeps the output tree. It's main task is keeping track of
	the current position in the output ParseTree. The idea is that if a
	new leaf or tree has to be appended this class will now where it
	goes.

	For this purpose we have a stack of ParseTrees which contains the
	ParseTrees which constitute the path from the root to the current
	position in the output tree.

	The output tree is the ParseTree self.stack[0]. The current position
	is the tree self.stack[-1].

	@ivar stack: stack which contains the path to the current position
	@type stack: [ParseTree]
	"""
	def __init__(self):
		self.stack = [ROOT()]

	def inserttree(self, tree):
		self.stack[-1].tree.append(tree)
		self.stack.append(tree)

	def insertleaf(self, leaf):
		self.stack[-1].tree.append(leaf)

	def closecontext(self):
		if len(self.stack) > 1:
			self.stack.pop()

	def getcontext(self):
		return self.stack[-1]

	def cleanup(self):
		self.stack = self.stack[0:1]

	def result(self):
		return self.stack[0]

class Parser:
	"""
	The actual parser.

	@ivar inputdata: the input to parse
	@type inputdata: unicode
	@ivar inputpos: the current position of the parser in the input string
	@type inputpos: int
	@ivar state: the current state of the parser, this contains the resulting tree
	@type state: State
	"""
	def __init__(self, inputdata=u""):
		## ensure newline at the end
		if inputdata[-1] != '\n':
			self.inputdata = inputdata + '\n'
		else:
			self.inputdata = inputdata
		self.inputpos = 0
		self.state = State()

	def retrievechunk(self):
		retcontent = u""
		if self.inputdata[self.inputpos] == '[':
			self.inputpos += 1
			regex = re.compile(ur'([ \t]*\][ \t]*\n?|[ \t]*\n[ \t]*\n)', re.UNICODE)
			match = regex.search(self.inputdata, self.inputpos)
			retcontent = self.inputdata[self.inputpos:match.start()]
			self.inputpos = match.end()
			rettree = HeadingTree()
		else:
			regex = re.compile(ur'\n', re.UNICODE)
			match = regex.search(self.inputdata, self.inputpos)
			retcontent = self.inputdata[self.inputpos:match.start()]
			self.inputpos = match.end()
			rettree = ParagraphTree()
		return rettree, retcontent

	def parsechunk(self, chunk):
		## here we need to parse a single chunk
		## no work done here yet
		for i in range(len(chunk)):
			self.state.insertleaf(TokenLeaf(chunk[i]))

	def parse(self):
		while True:
			if len(self.inputdata) <= self.inputpos:
				break
			## retrieve one line of input
			try:
				currenttree, content = self.retrievechunk()
			except IndexError:
				break
			self.state.inserttree(currenttree)
			self.parsechunk(content)
			self.state.closecontext()

	def result(self):
		return self.state.result()

p = Parser("[heading]\nSome text with _an_ emphasis.\n")
p.parse()
p.result().display(verbose=True)
