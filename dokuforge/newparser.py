class ParseLeaf:
	"""
	Leaf class for the tree generated by the parser.
	@ivar ident: type of the leaf. Valid types are Token, Word, Number,
                 Whitespace, Newline and Newpar.
	@ivar data: data contained by the leaf
	@type ident: str
	@type data: unicode
	"""
	def __init__(self, ident, data):
		self.ident = ident
		self.data = data

	def display(self, indent=0, verbose=False):
		"""
		Print a representation of the ParseLeaf.
		"""
		if not verbose:
			return
		whitespace = indent * u"    "
		print (u"%sParseLeaf: %s (%s)" % (whitespace, self.ident, self.data)).encode("utf8")

class ParseTree:
	"""
	Tree class for the tree generated by the parser.

	One instance is one node in the tree.

	@ivar tree: children of the tree
	@ivar ident: type of the node. Valid types are ROOT, heading, paragraph.
	@type tree: [ParseTree or ParseLeaf]
	@type ident: str
	"""
	def __init__(self, ident):
		self.tree = []
		self.ident = ident

	def display(self, indent=0, verbose=False):
		"""
		Print a representation of the ParseTree.
		"""
		whitespace = indent * u"    "
		print whitespace + u"ParseTree: " + self.ident
		for x in self.tree:
			x.display(indent + 1, verbose)

class State:
	"""
	Class to keep track of the current position in the output ParseTree.

    This has copies of the arrays so the insert* modify the output tree.
	"""
	def __init__(self, tree):
		self.layers = [tree]

	def inserttree(self, tree):
		self.layers[-1].tree.append(tree)
		self.layers.append(tree)

	def insertleaf(self, leaf):
		self.layers[-1].tree.append(leaf)

	def closelayer(self):
		if len(self.layers) > 1:
			self.layers.pop()

	def getcontext(self):
		return self.layers[-1]

	def cleanup(self):
		self.layers = [self.layers[0]]

class Parser:
	def __init__(self, string=u"", debug=False):
		## ensure newline at the end
		self.inputdata = string + '\n'
		self.inputpos = 0
		self.debug = debug
		self.tree = ParseTree("ROOT")

	def retrievechunk(self):
		retcontent = u""
		retterminated = False
		## this needs to be done nicely with regex
		## just a proof of concept
		if self.inputdata[self.inputpos] == '[':
			self.inputpos += 1
			rettree = ParseTree("heading")
			while True:
				if self.inputdata[self.inputpos] in [']', '\n']:
					if self.inputdata[self.inputpos] == [']']:
						retterminated = True
					self.inputpos += 1
					break
				retcontent += self.inputdata[self.inputpos]
				self.inputpos += 1
		else:
			rettree = ParseTree("paragraph")
			while True:
				if self.inputdata[self.inputpos] == '\n':
					self.inputpos += 1
					break
				retcontent += self.inputdata[self.inputpos]
				self.inputpos += 1
		return rettree, retcontent, retterminated

	def parsechunk(self, state, chunk):
		## here we need to parse a single chunk
		## no work done here yet
		for i in range(len(chunk)):
			state.insertleaf(ParseLeaf("Token", chunk[i]))

	def parse(self):
		"""
		The actual parser.
		"""
		state = State(self.tree)
		while True:
			## retrieve one line of input
			try:
				currenttree, content, terminated = self.retrievechunk()
			except IndexError:
				break
			## continue the last context if possible
			## this is at least necessary for paragraphs
			## but nice for other cases too
			if currenttree.ident != state.getcontext().ident:
				state.closelayer()
				state.inserttree(currenttree)
			else:
				currenttree = state.getcontext()
			## double newline ends everything
			if content == "\n":
				state.cleanup()
				continue
			self.parsechunk(state, content)
			if terminated:
				state.closelayer()

p = Parser("[heading]\ntext\n")
p.parse()
p.tree.display(verbose=True)
