# -*- coding: utf-8 -*-

class ParseLeaf:
    """
    Leaf class for the tree generated by the parser.

    @ivar ident: type of the leaf. Valid types are Token, Word, Number,
       Whitespace, Newline and Newpar.
    @ivar data: data contained by the leaf
    @type ident: str
    @type data: unicode
    """
    def __init__(self, ident, data):
        self.ident = ident
        self.data = data

    def isactive(self):
        """
        Leaves are never active.
        """
        return False

    def display(self, indent=0, verbose=False):
        """
        Print a representation of the ParseLeaf.
        """
        if not verbose:
            return
        whitespace = indent * u"    "
        print (u"%sParseLeaf: %s (%s)" % (whitespace, self.ident, self.data)).encode("utf8")

class ParseTree:
    """
    Tree class for the tree generated by the parser.

    One instance is one node in the tree. There is the notion of the current
    position in the tree. This position is the deepest active node. From the
    current position to the root, all nodes have to be active. These have to
    be the only active nodes.

    @ivar tree: children of the tree
    @ivar active: marks this position as awaiting modifications
    @ivar ident: type of the node. Valid types are all permanent states and
       "root".
    @type tree: [ParseTree or ParseLeaf]
    @type active: bool
    @type ident: str
    """
    def __init__(self, ident):
        self.tree = []
        self.active = True
        self.ident = ident

    def isactive(self):
        return self.active

    def insert(self, newtree):
        """
        Insert a new tree at the current position.

        The current position is determined by the active flag.
        """
        assert self.active
        if len(self.tree) == 0:
            self.tree.append(newtree)
            return
        if self.tree[-1].isactive():
            self.tree[-1].insert(newtree)
        else:
            self.tree.append(newtree)

    def close(self):
        """
        Mark the node at the current position as inactive.

        This moves the current position one level up. This acts like a
        popstate and returns the closed state.
        """
        assert self.active
        if len(self.tree) == 0:
            self.active = False
            return self.ident
        if self.tree[-1].isactive():
            return self.tree[-1].close()
        else:
            self.active = False
            return self.ident

    def display(self, indent=0, verbose=False):
        """
        Print a representation of the ParseTree.
        """
        whitespace = indent * u"    "
        marker = u""
        if self.isactive():
            marker = u"*"
        print whitespace + u"ParseTree: " + self.ident + marker
        for x in self.tree:
            x.display(indent + 1, verbose)

    def lookstate(self):
        """
        @returns: the ident of the current position
        """
        assert self.active
        if len(self.tree) == 0:
            return self.ident
        if self.tree[-1].isactive():
            return self.tree[-1].lookstate()
        else:
            return self.ident

    def lookactiveleaf(self):
        """
        @returns: If the last child of the current position is a ParseLeaf
          return it, otherwise return None.
        """
        assert self.active
        if len(self.tree) == 0:
            return None
        if isinstance(self.tree[-1], ParseTree):
            if self.tree[-1].active:
                return self.tree[-1].lookactiveleaf()
            else:
                return None
        else:
            return self.tree[-1]

    def appendtoleaf(self, data):
        """
        Append data to the last child of the current position. The caller
        has to ensure that this is a ParseLeaf.
        """
        assert self.active
        assert not len(self.tree) == 0
        if isinstance(self.tree[-1], ParseTree):
            assert self.tree[-1].isactive()
            self.tree[-1].appendtoleaf(data)
        else:
            assert isinstance(self.tree[-1], ParseLeaf)
            self.tree[-1].data += data


class Parser:
    """
    Class for parsing Dokuforge Syntax.

    The result is a tree representation of the input.

    It works by scanning the text one token at a time (with a bit of
    lookahead) and remembering all context in a tree and a stack, so the
    meaning of tokens change as the context changes.

    The context is distributed between the tree and the stack in the
    following way: The tree takes all permanent states which shall be
    included in the output; the stack takes all temporary states which are
    only important for the current state of the parser, but discarded once
    the have fulfilled their use. The stack has priority over the tree.

    @ivar input: the input string
    @ivar debug: toggles debug output
    @ivar pos: current position in the input string
    @ivar stack: contains the current context
    @ivar tree: is an abstract syntax tree of the input
    """

    def __init__(self, string=u"", debug=False):
        assert isinstance(string, unicode)
        self.input = string
        self.debug = debug
        self.pos = 0
        self.stack = [ "start" ]
        self.tree = ParseTree("root")

    def lookstate(self):
        """
        @rtype: str
        @returns: topmost state in the context
        """
        if len(self.stack) == 0:
            return self.tree.lookstate()
        else:
            return self.stack[-1]

    def mangletemporarystate(self, state):
        """
        Process temporary states if they are popped from self.stack.

        @param state: state to process
        @type state: str
        """
        ## the temporary tokens are the newline specials (all the *next)
        ## and the whitespace specials (seen* and wants*)
        assert state  in ("start", "headingnext", "listnext", "ednotenext",
                          "displaymathnext", "authorsnext", "keywordnext",
                          "wantsnewline","seenwhitespace", "seennewline",
                          "seennewpar")
        if state == "seenwhitespace":
            self.insertwhitespace()
        elif state in ("seennewline", "wantsnewline"):
            self.insertnewline()
        elif state == "seennewpar":
            self.insertnewpar()

    def popstate(self):
        """
        Remove a state from the context.

        This either means popping a state from the stack or closing a state
        in the tree.

        @rtype: str
        @returns: the removed state
        """
        if len(self.stack) == 0:
            return self.tree.close()
        else:
            state = self.stack.pop()
            self.mangletemporarystate(state)

    def pushstate(self, value):
        """
        Put a new state an top of the context.

        Corresponding to wether it is a temporary or a permanent state it
        either lands on the stack or in the tree, respectively.
        """
        ## the temporary tokens are the newline specials (all the *next)
        ## and the whitespace specials (seen* and wants*)
        if value in ("headingnext", "listnext", "ednotenext",
                     "displaymathnext", "authorsnext", "keywordnext",
                     "wantsnewline","seenwhitespace", "seennewline",
                     "seennewpar"):
            self.stack.append(value)
        ## the permanent states are all of the rest
        elif value in ("authors", "displaymath", "heading", "keyword",
                       "paragraph", "subheading","list", "item", "ednote",
                       "emphasis", "inlinemath", "nestedednote"):
            self.tree.insert(ParseTree(value))
        else:
            raise ValueError("invalid state: %s" % value)


    def changestate(self, state):
        """
        Change the current temporary state to another temporary state. The
        caller has to ensure that the current state is a temporary one.
        @type state: str
        """
        assert not len(self.stack) == 0
        ## the temporary tokens are the newline specials (all the *next)
        ## and the whitespace specials (seen* and wants*)
        assert state  in ("start", "headingnext", "listnext", "ednotenext",
                          "displaymathnext", "authorsnext", "keywordnext",
                          "wantsnewline","seenwhitespace", "seennewline",
                          "seennewpar")
        self.stack[-1] = state

    def poptoken(self):
        """
        Get a new token from the input string and advance the position in
        the input string.

        @rtype: char
        @returns: the char at the current position
        @raises IndexError
        """
        self.pos += 1
        return self.input[self.pos-1]

    def looktoken(self):
        """
        View the next token from the input string without side effects. If
        no token is available return an empty string.

        @rtype: char
        @returns: the next char
        """
        try:
            return self.input[self.pos]
        except IndexError:
            return u''

    def lookprintabletoken(self):
        """
        View the next non-whitespace token from the input string without
        side effects. If no token is available return an empty string.

        @rtype: char
        @returns: the next char
        """
        try:
            tmp = 0
            while self.input[self.pos + tmp] in u' \t\n':
                tmp += 1
            return self.input[self.pos + tmp]
        except IndexError:
            return u''

    def insertwhitespace(self):
        """
        Interface for putting whitespaces.
        """
        self.tree.insert(ParseLeaf("Whitespace", u" "))

    def insertnewline(self):
        """
        Interface for putting newlines.
        """
        self.tree.insert(ParseLeaf("Newline", u"\n"))

    def insertnewpar(self):
        """
        Interface for putting newpars.
        """
        self.tree.insert(ParseLeaf("Newpar", u"\n\n"))

    def insertdollar(self):
        """
        Interface for putting newlines.
        """
        self.tree.insert(ParseLeaf("Dollar", u"$"))

    def insertpercent(self):
        """
        Interface for putting newlines.
        """
        self.tree.insert(ParseLeaf("Percent", u"%"))

    def insertbackslash(self):
        """
        Interface for putting newlines.
        """
        self.tree.insert(ParseLeaf("Backslash", u"\\"))

    def put(self, s):
        """
        Append s as leaf at the current position in the tree.

        This tries to fuse normal characters with Word leaves and digits
        with Number leaves.

        @type s: unicode
        @param s: string to append
        """
        ## we don't want to process stuff in ednotes
        if not self.lookstate() in ("ednote", "nestedednote"):
            if s in u'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZäüößÄÖÜ':
                leaf = self.tree.lookactiveleaf()
                if leaf is None or not leaf.ident == "Word":
                    self.tree.insert(ParseLeaf("Word", s))
                else:
                    self.tree.appendtoleaf(s)
            elif s in u'0123456789':
                leaf = self.tree.lookactiveleaf()
                if leaf is None or not leaf.ident == "Number":
                    self.tree.insert(ParseLeaf("Number", s))
                else:
                    self.tree.appendtoleaf(s)
            else:
                self.tree.insert(ParseLeaf("Token", s))
        else:
            self.tree.insert(ParseLeaf("Token", s))

    def __str__(self):
        """
        Return representation of the current stack.

        This omits the context in the tree (maybe FIXME?).
        """
        return str(self.stack)

    def cleanup(self):
        """
        close all open states.

        This is triggered by newpars and several other contexts which should
        always be toplevel in the tree.
        @raises ValueError:
        """
        while not self.lookstate() == "root":
            currentstate = self.lookstate()
            if currentstate == "start":
                self.popstate()
            elif currentstate in ("authors", "displaymath", "heading",
                                  "keyword", "paragraph", "subheading",
                                  "authorsnext", "headingnext", "listnext",
                                  "keywordnext", "ednotenext",
                                  "displaymathnext", "list", "item", "ednote",
                                  "emphasis", "inlinemath", "nestedednote"):
                self.popstate()
            elif currentstate == "seenwhitespace":
                self.popstate()
            elif currentstate in ("seennewline", "wantsnewline"):
                self.popstate()
            ## paragraphs need to be treated specially since all contexts
            ## should be close, ere the paragraph is commited to the output
            elif currentstate == "seennewpar":
                if self.tree.lookstate() == "root":
                    self.popstate()
                else:
                    self.tree.close()
            else:
                raise ValueError("invalid state: %s" % currentstate)

    def predictnextstructure(self, token):
        """
        After a newline some future tokens have a special meaning. This
        function is to be called after every newline and marks these tokens
        as active.
        """
        if self.lookstate() in ("inlinemath", "displaymath", "ednote"):
            return
        if token == u'[':
            self.pushstate("headingnext")
        if token == u'-' and self.looktoken() in (u' ', u'\t'):
            self.pushstate("listnext")
        if token == u'{':
            self.pushstate("ednotenext")
        if token == u'$' and self.looktoken() == u'$':
            self.pushstate("displaymathnext")

    def deletetrailingwhitespace(self, tree=None):
        """
        Delete all trailing whitespace in tree (self.tree if no argument given).

        A trailing whitespace is a Whitespace leaf at the end of any node of
        the tree.
        """
        if tree is None:
            tree = self.tree
        if isinstance(tree, ParseLeaf):
            return
        if len(tree.tree) == 0:
            return
        while tree.tree[-1].ident == "Whitespace":
            tree.tree.pop()
            if len(tree.tree) == 0:
                return
        for x in tree.tree:
            self.deletetrailingwhitespace(x)

    def parse(self):
        """
        The actual parser.
        """
        while True:
            ## retrieve token
            try:
                token = self.poptoken()
            except IndexError:
                self.cleanup()
                break
            ## retrieve current state
            currentstate = self.lookstate()
            ## print some nice stuff if in debug mode
            ## actually useful, I quite missed something like this in the
            ## big cannons I tried before
            if self.debug:
                self.tree.display()
                print self
                print u"Token:", token.encode("utf8")
            ## process the token

            ## first handle ednotes
            ## here everything is copied verbatim
            if currentstate == "nestedednote":
                if token == u'{':
                    self.pushstate("nestedednote")
                elif token == u'}':
                    self.popstate()
                else:
                    self.put(token)
                continue
            if currentstate == "ednote":
                if token == u'{':
                    self.pushstate("nestedednote")
                elif token == u'}':
                    self.popstate()
                    self.pushstate("wantsnewline")
                else:
                    # the exporter guarantees no '\end{ednote}' is contained
                    self.put(token)
                continue

            ## second handle whitespace
            ## we contract whitespace as far as sensible
            if token in (u' ', u'\t'):
                if currentstate not in ("start", "seenwhitespace",
                                        "seennewline", "seennewpar",
                                        "wantsnewline"):
                    self.pushstate("seenwhitespace")
                continue
            elif token == u'\n':
                if currentstate in ("start", "seennewpar"):
                    pass
                elif currentstate in ("seenwhitespace", "wantsnewline"):
                    ## if we want a newline and there is one everything is nice
                    self.changestate("seennewline")
                elif currentstate == "seennewline":
                    self.changestate("seennewpar")
                else:
                    self.pushstate("seennewline")
                continue

            ## now we have a non-whitespace token so we clean up the state
            ## i.e. remove whitespace from the context
            ## a double newline ends all environments (except ednotes)
            if currentstate == "paragraph":
                ## minor optimization, but I feel it is worth it
                ## to shortcircuit this statement
                pass
            elif currentstate == "seenwhitespace":
                self.popstate()
            elif currentstate in ("seennewline", "wantsnewline"):
                self.popstate()
                ## activate special tokens
                self.predictnextstructure(token)
            elif currentstate == "seennewpar":
                ## handling of the seennewpar is done by cleanup
                self.cleanup()
                ## activate special tokens
                self.predictnextstructure(token)
            elif currentstate == "start":
                self.popstate()
                ## activate special tokens
                self.predictnextstructure(token)

            ## third handle math
            ## this deactivates all other special characters
            ## even ednotes since math needs curly braces
            if self.lookstate() in ("inlinemath", "displaymath"):
                ## one exception: look out for \ which escapes $
                if token == u'\\':
                    if self.looktoken() == u'$':
                        self.poptoken()
                        self.insertdollar()
                    else:
                        self.insertbackslash()
                ## math special token $
                elif token == u'$':
                    if currentstate == "inlinemath":
                        self.popstate()
                    else:
                        # displaymath
                        self.popstate()
                        if self.looktoken() == u'$':
                            self.poptoken()
                        self.pushstate("wantsnewline")
                else:
                    self.put(token)
                continue

            ## fourth if a new paragraph is beginning insert it into the context
            if self.lookstate() == "root":
                self.pushstate("paragraph")
                if token == u'*':
                    self.pushstate("keywordnext")

            ## update current state, since it could be modified
            currentstate = self.lookstate()

            ## fifth now we handle all printable tokens
            ### ednotes as { note to self }
            if token == u'{':
                self.cleanup()
                ## if we are at the beginnig of a line (as advertised by
                ## predictnextstructure) everything is okay, otherwise we
                ## have to insert a newline
                ## currentstate is unchanged by self.cleanup
                if not currentstate == "ednotenext":
                    self.insertnewline()
                self.pushstate("ednote")
            ### math in the forms $inline$ and $$display$$
            elif token == u'$':
                if self.looktoken() == u'$':
                    self.poptoken()
                    self.cleanup()
                    ## if we are at the beginnig of a line (as advertised by
                    ## predictnextstructure) everything is okay, otherwise we
                    ## have to insert a newline
                    ## currentstate is unchanged by self.cleanup
                    if not currentstate == "displaymathnext":
                        self.insertnewline()
                    self.pushstate("displaymath")
                else:
                    self.pushstate("inlinemath")
            ### [heading] and [[subheading]]
            ### with optional (authors) following
            elif token == u'[' and currentstate == "headingnext":
                self.popstate()
                self.cleanup()
                if self.looktoken() == u'[':
                    self.poptoken()
                    self.pushstate("subheading")
                else:
                    self.pushstate("heading")
            elif token == u']' and currentstate in ("heading", "subheading"):
                if currentstate == "heading":
                    self.popstate()
                    ## activate paren
                    if self.lookprintabletoken() == u'(':
                        self.pushstate("authorsnext")
                    self.pushstate("wantsnewline")
                elif currentstate == "subheading" and self.looktoken() == u']':
                    self.poptoken()
                    self.popstate()
                    ## activate paren
                    if self.lookprintabletoken() == u'(':
                        self.pushstate("authorsnext")
                    self.pushstate("wantsnewline")
                else:
                    self.put(token)
            ### (authors) only available after [heading] and [[subheading]]
            elif token == u'(' and currentstate == "authorsnext":
                self.popstate()
                self.pushstate("authors")
            elif token == u')' and currentstate == "authors":
                self.popstate()
                self.pushstate("wantsnewline")
            ### _emphasis_
            elif token == u'_':
                if currentstate == "emphasis":
                    self.popstate()
                else:
                    self.pushstate("emphasis")
            ### *keywords* only avalailable at the beginnig of paragraphs
            elif token == u'*' and currentstate in ("keywordnext", "keyword"):
                if currentstate == "keywordnext":
                    self.popstate()
                    self.pushstate("keyword")
                else: # keyword
                    self.popstate()
            ### lists only available at the beginning of lines
            ### - items
            ### - like
            ### - this
            elif token == u'-' and currentstate == "listnext" and \
                    self.looktoken() in (u' ', u'\t'):
                self.popstate()
                self.poptoken()
                if self.lookstate() == "item":
                    self.popstate()
                else:
                    self.cleanup()
                    self.pushstate("list")
                self.pushstate("item")
            ### dollar signs are escaped like \$
            elif token == u'\\':
                if self.looktoken() == u'$':
                    self.poptoken()
                    self.insertdollar()
                else:
                    self.insertbackslash()
            elif token == u'%':
                self.insertpercent()
            ### the default case for all the non-special tokens
            ### but escaping the special tokens
            else:
                self.put(token)

        ## these can happen in situations like 'a {}'
        self.deletetrailingwhitespace()

        ## close the root node, we are done
        self.tree.close()

        ## finally return the tree
        return self.tree
